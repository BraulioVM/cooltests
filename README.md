# `cooltests`

Self-discoverable C++ tests without using macros. This CMake module
lets you do:

```CMake
add_executable(mytest 
  tests/test1.cpp
  tests/test2.cpp
)
configure_cool_tests(mytest)
```

where neither `test1.cpp` nor `test2.cpp` provide a `main` function. They
just have to provide a few `void(void)` functions whose names begin by `test`
and then `cooltests` will link them into an executable that automatically runs
all of them.

Never use this project.

## Build this project

Requirements:
- python3.8
- cmake
- A modern-enough C++ compiler (I use `std::span`)
- nm

Build this project:

```
$ cmake -S . -B build -Dcooltests_OwnTests=1
$ cd build
$ make -j
$ ctest -V
```

## How to use this project

You shouldn't. But you can include it as a git submodule and `add_subdirectory` it.
Then you should be able to use `configure_cool_tests`.

Tests signal their failure by throwing. Pretty bad,
but simple.

## Caveats

There are many things that are broken:

- The object file generated by `cooltests.py` might be ABI-incompatible with the rest
  of your code.

- Test symbol detection is very broken. Anything that, once demangled by nm, 
  begins with `test` and ends with `()` will be considered as a test function in the
  global namespace. 
  
- The `cooltests.py` program probably makes assumptions about `nm`'s output that are
  too strict.

- ...
